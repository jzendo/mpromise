{"version":3,"sources":["status.js","util.js","index.js"],"names":["ensureStatusProxy","expect","s","PENDING","FULFILLED","REJECTED","isPending","isFulfilled","isRejected","isResolved","isFunction","f","isObject","o","runAsync","fn","setTimeout","flushPendingHandlers","promise","status","status_","handlers","pendingHandlers_","slice","value","value_","forEach","handler","Promise","undefined","resolve_","bind","reject_","TypeError","then","once","callerProxy","val","call","fulfill_","e","fillWith_","onFulfilled","onRejected","handleFulfillProxy","resolve","reject","handleRejectProxy","err","push","defer","pending"],"mappings":"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","file":"index.js","sourceRoot":"..\\src","sourcesContent":["const ensureStatusProxy = expect => s => s === expect\r\n\r\nexport const PENDING = 'pending'\r\nexport const FULFILLED = 'fulfilled'\r\nexport const REJECTED = 'rejected'\r\n\r\nexport const isPending = ensureStatusProxy(PENDING)\r\nexport const isFulfilled = ensureStatusProxy(FULFILLED)\r\nexport const isRejected = ensureStatusProxy(REJECTED)\r\n\r\nexport const isResolved = s => isFulfilled(s) || isRejected(s)\r\n","import { isFulfilled, isRejected, isResolved } from './status'\r\n\r\nexport const isFunction = f => f && typeof f === 'function'\r\nexport const isObject = o => o && typeof o === 'object'\r\nexport const runAsync = fn => {\r\n  setTimeout(fn, 0)\r\n}\r\n\r\nexport const flushPendingHandlers = promise => {\r\n  const status = promise.status_\r\n  if (!isResolved(status)) return\r\n\r\n  const handlers = promise.pendingHandlers_.slice(0)\r\n  const value = promise.value_\r\n\r\n  // Only for `extend`\r\n  if (process.env.IMPL === 'extend') {\r\n    // No rejected-handler\r\n    if (handlers.length == 0) {\r\n      // Throw when it is rejected\r\n      if (isRejected(status)) {\r\n        throw value\r\n      }\r\n    }\r\n  }\r\n\r\n  handlers.forEach(f => {\r\n    let handler\r\n\r\n    if (isFulfilled(status)) handler = f[0]\r\n    else if (isRejected(status)) handler = f[1]\r\n\r\n    if (handler) runAsync(() => handler(value))\r\n  })\r\n}\r\n","/*!\r\n *  A Promises/A+ implememt by jzendo\r\n *  - Specification: https://promisesaplus.com/\r\n */\r\n\r\nimport {\r\n  FULFILLED,\r\n  PENDING,\r\n  REJECTED,\r\n  isFulfilled,\r\n  isPending,\r\n  isRejected,\r\n  isResolved\r\n} from './status'\r\nimport {\r\n  flushPendingHandlers,\r\n  isFunction,\r\n  isObject,\r\n  runAsync\r\n} from './util'\r\n\r\n/**\r\n *  @class Promise\r\n */\r\nclass Promise {\r\n  constructor (fn) {\r\n    this.status_ = PENDING\r\n    this.value_ = undefined\r\n    this.pendingHandlers_ = []\r\n\r\n    fn(this.resolve_.bind(this), this.reject_.bind(this))\r\n  }\r\n\r\n  resolve_ (value) {\r\n    if (isResolved(this.status_)) return\r\n\r\n    if (value === this) {\r\n      throw new TypeError('Chaining cycle detected for promise')\r\n    } else if (value instanceof Promise) {\r\n      value.then(this.resolve_.bind(this), this.reject_.bind(this))\r\n    } else if (isFunction(value) || isObject(value)) {\r\n      let once = false\r\n\r\n      try {\r\n        const { then } = value\r\n\r\n        if (isFunction(then)) {\r\n          const callerProxy = fn => val => {\r\n            if (!once) {\r\n              fn(val)\r\n              once = true\r\n            }\r\n          }\r\n\r\n          then.call(\r\n            value,\r\n            callerProxy(this.resolve_.bind(this)),\r\n            callerProxy(this.reject_.bind(this))\r\n          )\r\n        } else {\r\n          this.fulfill_(value)\r\n        }\r\n      } catch (e) {\r\n        // https://promisesaplus.com/#point-55\r\n        // https://promisesaplus.com/#point-59\r\n        if (!once) this.reject_(e)\r\n      }\r\n    } else {\r\n      this.fulfill_(value)\r\n    }\r\n  }\r\n\r\n  fulfill_ (value) {\r\n    this.fillWith_(value, FULFILLED)\r\n  }\r\n\r\n  reject_ (value) {\r\n    this.fillWith_(value, REJECTED)\r\n  }\r\n\r\n  fillWith_ (value, status) {\r\n    if (isResolved(this.status_)) return\r\n\r\n    this.status_ = status\r\n    this.value_ = value\r\n\r\n    flushPendingHandlers(this)\r\n  }\r\n\r\n  then (onFulfilled, onRejected) {\r\n    const { status_, value_ } = this\r\n\r\n    const handleFulfillProxy = (resolve, reject) => val => {\r\n      try {\r\n        if (isFunction(onFulfilled)) resolve(onFulfilled(val))\r\n        else resolve(val)\r\n      } catch (e) {\r\n        reject(e)\r\n      }\r\n    }\r\n\r\n    const handleRejectProxy = (resolve, reject) => err => {\r\n      try {\r\n        if (isFunction(onRejected)) resolve(onRejected(err))\r\n        else reject(err)\r\n      } catch (e) {\r\n        reject(e)\r\n      }\r\n    }\r\n\r\n    // Status: pending\r\n    if (isPending(status_)) {\r\n      return new Promise((resolve, reject) => {\r\n        this.pendingHandlers_.push([\r\n          handleFulfillProxy(resolve, reject),\r\n          handleRejectProxy(resolve, reject)\r\n        ])\r\n      })\r\n    }\r\n\r\n    // Status: fulfilled\r\n    if (isFulfilled(status_)) {\r\n      return new Promise((resolve, reject) =>\r\n        // NOTE: onFulfilled should be called async mode\r\n        runAsync(() => {\r\n          handleFulfillProxy(resolve, reject)(value_)\r\n        })\r\n      )\r\n    }\r\n\r\n    // Status: rejected\r\n    if (isRejected(status_)) {\r\n      return new Promise((resolve, reject) =>\r\n        // NOTE: onRejected should be called async mode\r\n        runAsync(() => {\r\n          handleRejectProxy(resolve, reject)(value_)\r\n        })\r\n      )\r\n    }\r\n\r\n    // throw new Error('invalid status')\r\n  }\r\n}\r\n\r\nexport default Promise\r\n\r\n// Generate `defer` util\r\nexport const defer = () => {\r\n  const pending = {}\r\n\r\n  pending.promise = new Promise((resolve, reject) => {\r\n    pending.resolve = resolve\r\n    pending.reject = reject\r\n  })\r\n\r\n  return pending\r\n}\r\n"]}